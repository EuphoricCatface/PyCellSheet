Application Design Note
----

2024. 11. 24    First Draft
2024. 12. 01    Second Draft
2024. 12. 07    Third Draft

0. Meta
  - I think I'll name this app pyspread_sheet.
  - It's made out of pyspread.
  - Its twist is that it's closer to the conventional spreadsheet programs.
  - It also tries to eliminate some of the implicit/invisible/nondeterministic/spaghetti-ness from pyspread.
  - Each cell of the 0th row/column will have column/row-wide information, and (0,0) will have per-sheet info.
  - This way, 1st row will have the name "1", which will greatly reduce the risk of off-by-one errors while developing.
  - After these design notes get stabilized, I'll post these on some pyspread community and ask for some feedback, and how I should deal with program structures, re-branding and packaging automations.

1. Per-Sheet Initialization Script
  - You can import libraries and define per-sheet global variables here.
  - From the cells, you can refer to the global variables from the same sheet, or from another sheet with the sheet reference notation.
  - The cells won't be able to modify the global variables, so take them as more like const or preprocessor macros in C/C++.
  - Imports / global variables per sheet will be separated via local / global dict supplied for exec() and eval()
  - From this init area, you can't refer to the cells, or global variables from other sheets.
  - This script is evaluated only when you issue an update.
  - The code for the last update is buffered until the next update, and will be saved in the document into the (0,0) cell
  - The draft will be discarded on the app exit, will not be saved into the document, and the app will give a warning if there is one when saving / exiting
  - This script will, by default, also contain the seed for random, so that random won't result differently each run.
  - After evaluating the init script, the variables/imports are stored into a dict ({sheetname: global_dict}) to be used by the "External Reference Parser" (introduced later)
  - If there are global variables/function names that look like cell names, you get a warning.

2. Functions / Libraries
  - The functions for the expressions will be provided via imports in the per-sheet init script, including the basic ones.
  - from pyspread_sheet.math import *; from pyspread_sheet.date import *; from pyspread_sheet.finance import *.finance; ...
  - Don't like/want the functions provided? Well you can just not import them!
  - If you also want the functions organized in more pythonic way, you can just edit the import statements like `from pyspread_sheet import math`
  - The provided functions might be more pythonic rather than being true to the conventional spreadsheet functions.
  - i.e. `NOW()` can be an alias to `datetime.datetime.now()`.
  - The names of the provided functions are in uppercase. Otherwise, the Python built-ins like sum() will be overwritten.
  - You can also create your own libraries and import them.
  - MAYBE_DITCH: If you have duplicate function names in the imports, you get a warning.
  - Importing libraries inside a cell locally is also allowed.

3. Cell Evaluation Pipeline
  - Cell Contents is whatever the user typed into the cell.
  - Expression Parser detects whether the contents is code to be further evaluated, or another type that doesn't need to go through the pipeline.
  - External Reference Parser detects the cell references and sheet references, and make them available for the evaluation.
  - Python Evaluator evaluates the input string as Python expressions and returns a Result, a Python object
  - Formatter gets a Python object, and produces a string to display for the cell.
  - The whole pipeline can be visualized like this:
      Cell                         [ Extern.   ]                                                               Cell
    Contents --[ Expression ]--> --[ Reference ]--> --[   Python  ]-->       Result      --[Formatter]-->  Representation
      (str)    [   Parser   ]      [   Parser  ]      [ Evaluator ]     (Python object)                       (str)

4. Expression Parser
  - Thanks to Garmy for the suggestion which eventually became this Expression Parser.
  - The Expression Parser is customizable per sheet.
  - The Expression Parser gets the argument `cell`, the Cell Contents copied, in string.
  - And it returns a Python object or a pyspread_sheet.???.PythonCode type object, which is a subclass of str.
  - If the return type is not PythonCode, then it is immediately the Result.
  - A PythonCode type object bypassing the rest of the evaluation pipeline is not possible.
  - If needed, you should be able to write/generate a code that evaluates to be a PythonCode after the pipeline.
  - There's an additional, invisible Expression Parser before the main one, that immediately evaluates an empty cell, and returns pyspread_sheet.???.EmptyCell, which is an `object()` as a constant.
  - This makes not ignoring None easier, and also hopefully saves computation from evaluating None on empty cells.
  - A warning is made if an EmptyCell is returned from the main Expression Parser. Making a cell with its expression hidden from sight is highly discouraged.
  - Four examples are provided for the users:
  * "Pure Pythonic" mode:
    	return PythonCode(cell)
  * "Mixed" mode:
        # Inspired by the spreadsheet string marker
        if cell.startswith('\''):
            return cell[1:]
        return PythonCode(cell)
  * "Reverse-mixed" mode:
        # Inspired by the python shell prompt `>>>`
        if cell.startswith(">"):
            return PythonCode(cell[1:])
        if cell.startswith('\''):
            cell = cell[1:]
        return cell
  * "Pure spreadsheet" mode:
        if cell.startswith("="):
            return PythonCode(cell[1:])
        try:
            return int(cell)
        except ValueError:
            pass
        try:
            return float(cell)
        except ValueError:
            pass
        if cell.startswith('\''):
            cell = cell[1:]
        return cell
  - The "Reverse-mixed" mode is the default and "Mixed" is the recommended, to balance between attracting less experienced people, and being pythonic.
  - The rationale is that if a not-tech-savvy first-timer tried out (supposedly) an office suite program, and then typing random stuff resulted in an error, then they would get frustrated and/or intimidated, and abandon the program soon.
  - Hopefully they will feel "achieving something" by switching to more advanced "Mixed" mode :3

5. External Reference Parser
  - To me, This name feels like it's about handling references from other cells to the current cell?
  - Each cell has an address, resembling spreadsheet ones.
  - The program will do a "preprocessor pass" of External Reference Parser before the evaluation of each cell.
  - A cell reference expression will be wrapped with quotation marks (' or ") to make it a string, and then wrapped with a function call of `cell_ref()`.
  - At least, until we find a better way to parse/convert it.
  - This function, `cell_ref()`, can be explicitly written in the cell.
  - And maybe this way will be recommended, because explicit is (always? mostly?) good.
  - The range specifier colon(:) and sheet specifier exclamation mark(!) also will be supported.
  - Filename specifier square brackets([]) will not be supported for now.
  - Range specifier and sheet specifier can also be explicitly written as `cell_range_ref()` and `sheet_ref()`.
  - And the single-cell version of the function is `cell_single_ref()`.
  - Sheet and cell reference can be chained like `sheet_ref("Sheet 1").cell_single_ref("A1")`.
  - ok maybe this is too verbose. maybe explicit is not always good...
  - The result of the range expression/function will be of pyspread_sheet.???.Range type that is a 2D list, additionally with the top-left cell's name/coordinate.
  - This is because of the search functions and such.
  - The Range type will additionally have a method to return a 1D list that has all the elements.
  - This will hopefully make it easier / faster to write / evaluate ones like sum() or average().
  - The return value of these reference functions will always be a deepcopy.
  - A1 `[1, 2, 5, 3, 4]`, A2 `A1.sort()` => A1 will stay the same, A2 will show `None`.
  - A1 `[1, 2, 5, 3, 4]`. A2 `a = A1; a.sort(); a` => A1 will stay the same, A2 will show the sorted list.
  - External Reference Parser also takes care of referencing the global variables declared in another sheet of Per-Sheet Initialization Script.
  - The "global variables" from the scripts will have been registered to the sheet object.
  - Global variables from the same sheet are to be supplied into the evaluator into the exec()/eval() via global dict arg.
  - If a keyword after sheet specifier doesn't look like a cell reference, sheet_ref() will be chained with global_ref() instead.

6. Python Evaluator
  - A cell can have a Result with the type of int, float, list, set, dict, str, bytes, or any python objects!
  - A statement is delimitered with semicolons or line breaks.
  - No variables will be shared outside of a cell. Only the result can be referred to by the address.
  - The result of the last statement in the cell will become the Result of the cell.
  - That is, mostly like how REPL (the python shell) shows you back the calculation results, except `None` doesn't get ignored.
  - That also means, if you have an assignment as the last statement, the cell will only show  ̶a̶ ̶`̶N̶o̶n̶e̶`̶  an error.
  - Why would you need that?? I said no variables will be shared anyways!
  - As mentioned in the 5th topic, global variables from the same sheet are to be supplied into the evaluator into the exec()/eval() via global dict arg
  - The code will be enclosed in a dummy function, to ensure it's evaluated inside its own local scope.
  - Like how you're recommended to make a main() in a standalone script.

7. Formatter
  - Formatter is a function, gets an argument `result`, returns a string.
  - Formatter evaluates the Result if it recognizes the type, else applies str().
  - For a sheet, Formatter has basically a bunch of `if isinstance(result, [TYPE/CLASS]):; return ...` clauses with `return str(result)` at the end.
  - This can also be implemented with match ~ case with "class patterns".
  - For a cell, Formatter is a single `if isinstance(result, [TYPE/CLASS]):; return ...; else raise SomeFormatException`.
  - This way, you can have different representations for each cell for e.g. `datetime.datetime`.
  - Any formatting resulting in an empty/whitespace-only string makes a warning, unless the cell is empty. Making a cell with its expression hidden from sight is highly discouraged.
  - If needed, showing "_" instead is encouraged.
  - For an error/exception, display the exception name and show details in the tooltip.
  - For a non-error/exception, display the formatted string and show type in the tooltip.
  - If warning, show a red dot on the top left corner of the cell.

TODO:
  - Figure out cell handle dragging
  - For now, pyspread syntax is preserved, but it may be purged if needed
  - If it doesn't, then toggling the headers between spreadsheet / pyspread mode will need to be implemented.
  - While "frozen cell" doesn't look very interesting, "generator cell" does. Look into it more later.

