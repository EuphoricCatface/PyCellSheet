Application Design Note
----

2024. 11. 24    First Draft
2024. 12. 01    Second Draft
[WIP]           Third Draft

0. Meta
  - I think I'll name this app pyspread_sheet.
  - It's made out of pyspread.
  - Its twist is that it's closer to the conventional spreadsheet programs.
  - The 0th row/column will have column/row-wide informations, and (0,0) will have per-sheet info.
  - This way, 1st row will have the name “1”, which will greatly reduce the risk of off-by-one error while developing.
1. Per-Sheet Initialization Script
  - You can import libraries and define per-sheet global variables here.
  - From the cells, you can refer to the global variables from the same sheet, or from another sheet with the sheet reference notation.
  - The cells won't be able to modify the global variables, so take them as more like const or preprocessor macros in C/C++.
  - Imports / global variables per sheet will be separated via local / global dict supplied for exec() and eval()
  - From this init area, you can't refer to the cells, or global variables from other sheets.
  - This script is evaluated only when you issue an update.
  - The code for the last update is buffered until the next update, and will be saved in the document into the (0,0) cell
  - The draft will be discarded on the app exit, will not be saved into the document, and the app will give a warning if there is one when saving / exiting
  - This script will, by default, also contain the seed for random, so that random won't result differently each run.
  - After evaluating the init macro, global variables are filtered out
    to be used by the “External Reference Parser" (introduced later)
  - If there are global variables/function names that look like cell names, you get a warning.
2. Functions / Libraries
  - The functions for the expressions will be provided via imports in the per-sheet init script, including the basic ones.
  - from pyspread_sheet.math import *; from pyspread_sheet.date import *; from pyspread_sheet.finance import *.finance; ...
  - Don't like/want the functions provided? Well you can just not import them!
  - If you also want the functions organized in more pythonic way, you can just edit the import statements like `from pyspread_sheet import math`
  - The provided functions might be more pythonic rather than being true to the conventional spreadsheet functions.
  - You can also create your own libraries and import them.
  - MAYBE_DITCH: If you have duplicate function names in the imports, you get a warning.
  - Importing libraries inside a cell locally is also allowed.
  - TODO: Figure out how to make the cell scope a local scope. Enclose the expressions with a dummy function, in the Evaluator?
3. Cell Evaluation Pipeline
  - Cell Contents is whatever the user typed into the cell.
  - Expression Parser detects whether the contents is code to be further evaluated, or another type that doesn't need to go through the pipeline.
  - External Reference Parser detects the cell references and global variables, and make them available for the evaluation.
  - Python Evaluator evaluates the input string as Python expressions and returns a Result, a Python object
  - Formatter gets a Python object, and produces a string to display for the cell.
  - The whole pipeline can be visualized like this:
      Cell                         [ Extern.   ]                                                               Cell
    Contents --[ Expression ]--> --[ Reference ]--> --[   Python  ]-->       Result      --[Formatter]-->  Representation
      (str)    [   Parser   ]      [   Parser  ]      [ Evaluator ]     (Python object)                       (str)

4. Expression Parser
  - Thanks to Garmy for the suggestion which eventually became this Expression Parser.
  - The Expression Parser is customizable per sheet.
  - The Expression Parser gets the argument `cell`, the Cell Contents copied, in string.
  - And it returns a tuple, `ret[0]` being a Python object, `ret[1]` being a bool
  - If `ret[0]` is a `str` object and ret[1] is `True`, then `ret[0]` is code to be evaluated.
    (Maybe I should make a constant/enum to make it neater?)
  - If ret[1] is False, then `ret[0]` is immediately the Result.
  - (Deleted: further specification can be found in the Addendum 1.)
  - There's an additional, invisible Expression Parser before the main one, that immediately evaluates an empty cell, and returns some other const than None. `(..., False)` maybe?
  - This makes not ignoring None easier, and also hopefully saves computation from evaluating None on empty cells.
  - Explicitly returning `(..., False)` from the main Expression Parser results in a warning. Making a cell with its expression hidden from sight is highly discouraged.
  - Four examples are provided for the users:
  - "Pure Pythonic" mode:
    	return (cell, True)
  - "Mixed" mode:
        if cell.startswith(">"):
            return (cell[1:], True)
        if cell.startswith('\''):
            cell = cell[1:]
        return (cell, False)
  - "Reverse Mixed" mode:
        if cell.startswith("'"):
            return (cell[1:], False)
        return (cell, True)
  - "Pure spreadsheet" mode:
        if cell.startswith("="):
            return (cell[1:], True)
        try:
            return (int(cell), False)
        except ValueError:
            pass
        try:
            return (float(cell), False)
        except ValueError:
            pass
        if cell.startswith('\''):
            cell = cell[1:]
        return (cell, False)
  - The "Mixed" mode is the default, to balance between attracting less experienced people and being pythonic.
5. External Reference Parser
  - This name feels to me about handling references from other cells to the current cell?
  - Each cell has an address, resembling spreadsheet ones.
  - The program will do a "preprocessor pass" of External Reference Parser before the evaluation of each cell.
  - A cell reference expression will be wrapped with quotation marks (' or ") to make it a string, and then wrapped with a function call of `cell_ref()`.
  - At least, until we find a better way to parse/convert it.
  - This function, `cell_ref()`, can be explicitly written in the cell.
  - And maybe this way will be recommended, because explicit is (always? mostly?) good.
  - We need to consider the range specifier colon(:), sheet specifier exclamation mark(!).
  - Filename specifier square brackets([]) will not be supported for now.
  - Range specifier and sheet specifier can also be explicitly written as `cell_range_ref()` and `sheet_ref()`.
  - And the single-cell version of the function is `cell_single_ref()`.
  - Maybe sheet and cell reference can be chained like `sheet_ref("Sheet 1").cell_single_ref("A1")`.
  - ok maybe this is too verbose. maybe explicit is not always good...
  - The result of the range expression/function will be of pyspread_sheet.range type that has a 2D list, along with the top-left cell's name/coordinate.
  - This is because of the search functions and such.
  - The range type will additionally have a method to return a 1D list that has all the elements.
  - This will hopefully make it easier / faster to write / evaluate ones like sum() or average().
  - The return value of these reference functions will always be a deepcopy.
  - A1 `[1, 2, 5, 3, 4]`, A2 `A1.sort()` => A1 will stay the same, A2 will show `None`.
  - A1 `[1, 2, 5, 3, 4]`. A2 `a = A1; a.sort(); a` => A1 will stay the same, A2 will show the sorted list.
  - External Reference Parser also takes care of referencing the global variables declared in another sheet of Per-Sheet Initialization Script.
  - The “global variables” from the scripts will have been filtered into a dict.
  - Global variables from the same sheet are to be supplied into the evaluator into the exec()/eval() via global dict arg
  - If a keyword after sheet specifier doesn't look like a cell reference, sheet_ref() will be chained with global_ref() instead.
6. Python Evaluator
  - A cell can have a Result with the type of int, float, list, set, dict, str, bytes, or any python objects!
  - A statement is delimitered with semicolons or line breaks.
  - No variables will be shared outside of a cell. Only the result can be referred to by the address.
  - The result of the last statement in the cell will become the Result of the cell.
  - That is, mostly like how REPL (the python shell) shows you back the calculation results, except `None` doesn't get ignored.
  - That also means, if you have an assignment as the last statement, the cell will only show  ̶a̶ ̶`̶N̶o̶n̶e̶`̶  an error.
  - Why would you need that?? I said no variables will be shared anyways!
  - As mentioned in the 5th topic, global variables from the same sheet are to be supplied into the evaluator into the exec()/eval() via global dict arg
7. Formatter
  - Formatter is a function, gets an argument `result`, returns a string.
  - Formatter evaluates the Result if it recognizes the type, else applies str().
  - For a sheet, Formatter has basically a bunch of `if isinstance(result, [TYPE/CLASS]):; return ...` clauses with `return str(result)` at the end.
  - This can also be implemented with match ~ case with "class patterns".
  - For a cell, Formatter is a single `if isinstance(result, [TYPE/CLASS]):; return ...; else raise SomeFormatException`.
  - This way, you can have different representations for each cell for e.g. `datetime.datetime`.
  - Any formatting resulting in empty/whitespace-only string makes a warning, unless cell is empty. Making a cell with its expression hidden from sight is highly discouraged.
  - If needed, showing "_" instead is encouraged.
TODO:
  - Figure out cell handle dragging
  - (Deleted: Figure out merging cells) - pyspread already has this
  - For now, pyspread syntax is preserved, but it may be purged if needed
  - If it doesn't, then toggling the headers between spreadsheet / pyspread mode will need to be implemented.
